"""
Format Converter for transcription results.
Handles VTT subtitle formatting and multi-language report generation.
"""

from typing import Dict, List, Any


class FormatConverter:
    """Converts transcription results to various output formats."""

    # Common language code to name mapping
    LANGUAGE_NAMES = {
        'en': 'English',
        'es': 'Spanish',
        'fr': 'French',
        'de': 'German',
        'it': 'Italian',
        'pt': 'Portuguese',
        'pl': 'Polish',
        'nl': 'Dutch',
        'ru': 'Russian',
        'zh': 'Chinese',
        'ja': 'Japanese',
        'ko': 'Korean',
        'ar': 'Arabic',
        'he': 'Hebrew',
        'th': 'Thai',
        'vi': 'Vietnamese',
        'tr': 'Turkish',
        'cs': 'Czech',
        'ro': 'Romanian',
        'sv': 'Swedish',
        'da': 'Danish',
        'no': 'Norwegian',
        'fi': 'Finnish',
        'el': 'Greek',
        'hi': 'Hindi',
        'id': 'Indonesian',
        'uk': 'Ukrainian',
        'unknown': 'Unknown'
    }

    @staticmethod
    def format_as_vtt(transcription_result: Dict[str, Any]) -> str:
        """
        Format transcription result as VTT subtitle file.

        Args:
            transcription_result: Result dictionary from transcribe()

        Returns:
            str: VTT formatted subtitle content
        """
        segments = transcription_result.get('segments', [])
        vtt_content = ["WEBVTT\n"]

        for i, segment in enumerate(segments, start=1):
            start_time = FormatConverter._format_vtt_timestamp(segment['start'])
            end_time = FormatConverter._format_vtt_timestamp(segment['end'])
            text = segment['text'].strip()

            vtt_content.append(f"{start_time} --> {end_time}\n{text}\n")

        return "\n".join(vtt_content)

    @staticmethod
    def _format_vtt_timestamp(seconds: float) -> str:
        """
        Format seconds as VTT timestamp (HH:MM:SS.mmm).

        Args:
            seconds: Time in seconds

        Returns:
            str: Formatted VTT timestamp
        """
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)
        millis = int((seconds % 1) * 1000)

        return f"{hours:02d}:{minutes:02d}:{secs:02d}.{millis:03d}"

    @staticmethod
    def format_timestamp_readable(seconds: float) -> str:
        """
        Format seconds as human-readable timestamp (MM:SS or HH:MM:SS).

        Args:
            seconds: Time in seconds

        Returns:
            str: Formatted readable timestamp
        """
        hours = int(seconds // 3600)
        minutes = int((seconds % 3600) // 60)
        secs = int(seconds % 60)

        if hours > 0:
            return f"{hours}:{minutes:02d}:{secs:02d}"
        else:
            return f"{minutes}:{secs:02d}"

    @staticmethod
    def format_multilang_report(result: Dict[str, Any]) -> str:
        """
        Format a detailed multi-language transcription report.

        Args:
            result: Enhanced transcription result with language info

        Returns:
            Formatted report string
        """
        report = []
        report.append("=" * 60)
        report.append("MULTI-LANGUAGE TRANSCRIPTION REPORT")
        report.append("=" * 60)
        report.append("")

        # Overall info
        detected_lang = result.get('language', 'unknown')
        lang_name = FormatConverter.LANGUAGE_NAMES.get(detected_lang, detected_lang)
        report.append(f"Primary Language: {lang_name} ({detected_lang.upper()})")
        report.append("")

        # Language segments
        if 'language_segments' in result:
            segments = result['language_segments']
            report.append(f"Language Segments Detected: {len(segments)}")
            report.append("")

            for i, seg in enumerate(segments, 1):
                start_str = FormatConverter.format_timestamp_readable(seg['start'])
                end_str = FormatConverter.format_timestamp_readable(seg['end'])
                lang = seg['language']
                lang_name = FormatConverter.LANGUAGE_NAMES.get(lang, lang)

                report.append(f"Segment {i}: {lang_name} ({lang.upper()}) [{start_str} - {end_str}]")
                report.append(f"  {seg['text'][:100]}...")
                report.append("")

        # Timeline
        if 'language_timeline' in result:
            report.append("Language Timeline:")
            report.append("-" * 60)
            report.append(result['language_timeline'])
            report.append("")

        report.append("=" * 60)

        return "\n".join(report)
